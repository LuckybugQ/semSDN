package dk.i1.diameter.node;
import java.util.Random;

class ConnectionTimers {
	long last_activity;
	long last_real_activity;
	long last_in_dw;
	boolean dw_outstanding;
	long cfg_watchdog_timer;
	long watchdog_timer_with_jitter;
	long cfg_idle_close_timeout;
	
	//Return -2000..+2000 as per rfc3539 section 3.4.1 item 1:
	//
	//In order to avoid synchronization behaviors that can occur with
	//fixed timers among distributed systems, each time the watchdog
	//interval is calculated with a jitter by using the Twinit value
	//and randomly adding a value drawn between -2 and 2 seconds.
	//Alternative calculations to create jitter MAY be used.  These
	//MUST be pseudo-random, generated by a PRNG seeded as per
	//[RFC1750].
	private static Random random=null;
	private static synchronized long generateJitter() {
		if(random==null) {
			String v = System.getProperty("dk.i1.diameter.node.jitter_prng");
			if(v==null)
				v="SHA1PRNG";
			if(!v.equals("bogus")) {
				try {
					random = java.security.SecureRandom.getInstance("SHA1PRNG");
				} catch(java.security.NoSuchAlgorithmException ex) {
				}
			}
			if(random==null) {
				random = new Random();
			}
		}
		//Random.nextBytes() returns multiplums of 8 bits  but we need
		//-2000..+2000 = 4001 values with no bias.
		//We cheat on just use 4096
		byte[] r = new byte[2];
		random.nextBytes(r);
		
		int x = r[0]*256+r[1];
		if(x<0) x+= 65536;
		x %= 4001;
		x -= 2000;
		return x;
	}
	
	
	public ConnectionTimers(long watchdog_timer, long idle_close_timeout) {
		last_activity = System.currentTimeMillis();
		last_real_activity = System.currentTimeMillis();
		last_in_dw = System.currentTimeMillis();
		dw_outstanding = false;
		cfg_watchdog_timer = watchdog_timer;
		watchdog_timer_with_jitter = cfg_watchdog_timer+generateJitter();
		cfg_idle_close_timeout = idle_close_timeout;
	}
	
	public void markDWR() { //got a DWR
		last_in_dw = System.currentTimeMillis();
	}
	public void markDWA() { //got a DWA	
		last_in_dw = System.currentTimeMillis();
		dw_outstanding = false;
	}
	public void markActivity() { //got something
		last_activity = System.currentTimeMillis();
	}
	public void markCER() { //got a CER
		last_activity = System.currentTimeMillis();
	}
	public void markRealActivity() { //got something non-CER, non-DW
		last_real_activity = last_activity;
	}
	public void markDWR_out() { //sent a DWR
		dw_outstanding = true;
		last_activity = System.currentTimeMillis();
		watchdog_timer_with_jitter = cfg_watchdog_timer + generateJitter();
	}
	
	public enum timer_action {
		none,
		disconnect_no_cer,
		disconnect_idle,
		disconnect_no_dw,
		dwr
	}

	public long calcNextTimeout(boolean ready) {
		if(!ready) {
			//when we haven't received a CER or negotiated TLS it will time out
			return last_activity + watchdog_timer_with_jitter;
		}
		
		long next_watchdog_timeout;

		if(!dw_outstanding)
			next_watchdog_timeout = last_activity + watchdog_timer_with_jitter; //when to send a DWR
		else
			next_watchdog_timeout = last_activity + watchdog_timer_with_jitter + cfg_watchdog_timer; //when to kill the connection due to no response

		if(cfg_idle_close_timeout!=0) {
			long idle_timeout;
			idle_timeout = last_real_activity + cfg_idle_close_timeout;
			if(idle_timeout<next_watchdog_timeout)
				return idle_timeout;
		}
		return next_watchdog_timeout;
	}
	
	public timer_action calcAction(boolean ready) {
		long now = System.currentTimeMillis();

		if(!ready) {
			if(now >= last_activity + watchdog_timer_with_jitter)
			{
				return timer_action.disconnect_no_cer;
			}
			return timer_action.none;
		}
		
		if(cfg_idle_close_timeout!=0) {
			if(now >= last_real_activity + cfg_idle_close_timeout)
			{
				return timer_action.disconnect_idle;
			}
		}
		
		//section 3.4.1 item 1
		if(now >= last_activity + watchdog_timer_with_jitter) {
			if(!dw_outstanding) {
				return timer_action.dwr;
			} else {
				if(now >= last_activity + cfg_watchdog_timer + cfg_watchdog_timer) {
					//section 3.4.1 item 3+4
					return timer_action.disconnect_no_dw;
				}
			}
		}
		return timer_action.none;
	}
}
